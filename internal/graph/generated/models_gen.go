// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"fmt"
	"io"
	"strconv"
	"time"
)

type Authentication struct {
	ID         string                 `json:"id"`
	UserID     string                 `json:"userID"`
	Provider   AuthenticationProvider `json:"provider"`
	Identifier string                 `json:"identifier"`
	UpdatedAt  time.Time              `json:"updatedAt"`
	CreatedAt  time.Time              `json:"createdAt"`
	User       *User                  `json:"user"`
}

type Task struct {
	ID                string          `json:"id"`
	TradingAccountID  string          `json:"tradingAccountID"`
	Cron              string          `json:"cron"`
	NextExecutionTime time.Time       `json:"nextExecutionTime"`
	IsActive          bool            `json:"isActive"`
	Type              string          `json:"type"`
	UpdatedAt         time.Time       `json:"updatedAt"`
	CreatedAt         time.Time       `json:"createdAt"`
	TradingAccount    *TradingAccount `json:"tradingAccount"`
	TaskHistories     []*TaskHistory  `json:"taskHistories"`
}

type TaskHistory struct {
	ID        string    `json:"id"`
	TaskID    string    `json:"taskID"`
	IsSuccess bool      `json:"isSuccess"`
	UpdatedAt time.Time `json:"updatedAt"`
	CreatedAt time.Time `json:"createdAt"`
	Task      *Task     `json:"task"`
}

type TradingAccount struct {
	ID         string    `json:"id"`
	UserID     string    `json:"userID"`
	Exchange   string    `json:"exchange"`
	Currency   string    `json:"currency"`
	IP         string    `json:"ip"`
	Identifier string    `json:"identifier"`
	UpdatedAt  time.Time `json:"updatedAt"`
	CreatedAt  time.Time `json:"createdAt"`
	User       *User     `json:"user"`
	Tasks      []*Task   `json:"tasks"`
}

type User struct {
	ID              string            `json:"id"`
	Name            string            `json:"name"`
	Timezone        string            `json:"timezone"`
	UpdatedAt       time.Time         `json:"updatedAt"`
	CreatedAt       time.Time         `json:"createdAt"`
	Authentications []*Authentication `json:"authentications"`
	TradingAccounts []*TradingAccount `json:"tradingAccounts"`
}

// UserWhereInput is used for filtering User objects.
// Input was generated by ent.
type UserWhereInput struct {
	Not *UserWhereInput   `json:"not"`
	And []*UserWhereInput `json:"and"`
	Or  []*UserWhereInput `json:"or"`
	// id field predicates
	ID      *string  `json:"id"`
	IDNeq   *string  `json:"idNEQ"`
	IDIn    []string `json:"idIn"`
	IDNotIn []string `json:"idNotIn"`
	IDGt    *string  `json:"idGT"`
	IDGte   *string  `json:"idGTE"`
	IDLt    *string  `json:"idLT"`
	IDLte   *string  `json:"idLTE"`
	// name field predicates
	Name             *string  `json:"name"`
	NameNeq          *string  `json:"nameNEQ"`
	NameIn           []string `json:"nameIn"`
	NameNotIn        []string `json:"nameNotIn"`
	NameGt           *string  `json:"nameGT"`
	NameGte          *string  `json:"nameGTE"`
	NameLt           *string  `json:"nameLT"`
	NameLte          *string  `json:"nameLTE"`
	NameContains     *string  `json:"nameContains"`
	NameHasPrefix    *string  `json:"nameHasPrefix"`
	NameHasSuffix    *string  `json:"nameHasSuffix"`
	NameIsNil        *bool    `json:"nameIsNil"`
	NameNotNil       *bool    `json:"nameNotNil"`
	NameEqualFold    *string  `json:"nameEqualFold"`
	NameContainsFold *string  `json:"nameContainsFold"`
	// timezone field predicates
	Timezone             *string  `json:"timezone"`
	TimezoneNeq          *string  `json:"timezoneNEQ"`
	TimezoneIn           []string `json:"timezoneIn"`
	TimezoneNotIn        []string `json:"timezoneNotIn"`
	TimezoneGt           *string  `json:"timezoneGT"`
	TimezoneGte          *string  `json:"timezoneGTE"`
	TimezoneLt           *string  `json:"timezoneLT"`
	TimezoneLte          *string  `json:"timezoneLTE"`
	TimezoneContains     *string  `json:"timezoneContains"`
	TimezoneHasPrefix    *string  `json:"timezoneHasPrefix"`
	TimezoneHasSuffix    *string  `json:"timezoneHasSuffix"`
	TimezoneIsNil        *bool    `json:"timezoneIsNil"`
	TimezoneNotNil       *bool    `json:"timezoneNotNil"`
	TimezoneEqualFold    *string  `json:"timezoneEqualFold"`
	TimezoneContainsFold *string  `json:"timezoneContainsFold"`
	// updated_at field predicates
	UpdatedAt      *time.Time   `json:"updatedAt"`
	UpdatedAtNeq   *time.Time   `json:"updatedAtNEQ"`
	UpdatedAtIn    []*time.Time `json:"updatedAtIn"`
	UpdatedAtNotIn []*time.Time `json:"updatedAtNotIn"`
	UpdatedAtGt    *time.Time   `json:"updatedAtGT"`
	UpdatedAtGte   *time.Time   `json:"updatedAtGTE"`
	UpdatedAtLt    *time.Time   `json:"updatedAtLT"`
	UpdatedAtLte   *time.Time   `json:"updatedAtLTE"`
	// created_at field predicates
	CreatedAt      *time.Time   `json:"createdAt"`
	CreatedAtNeq   *time.Time   `json:"createdAtNEQ"`
	CreatedAtIn    []*time.Time `json:"createdAtIn"`
	CreatedAtNotIn []*time.Time `json:"createdAtNotIn"`
	CreatedAtGt    *time.Time   `json:"createdAtGT"`
	CreatedAtGte   *time.Time   `json:"createdAtGTE"`
	CreatedAtLt    *time.Time   `json:"createdAtLT"`
	CreatedAtLte   *time.Time   `json:"createdAtLTE"`
	// authentications edge predicates
	HasAuthentications *bool `json:"hasAuthentications"`
	// trading_accounts edge predicates
	HasTradingAccounts *bool `json:"hasTradingAccounts"`
}

type UserWithOptions struct {
	WithTradingAccounts bool `json:"withTradingAccounts"`
	WithAuthentications bool `json:"withAuthentications"`
}

type AuthenticationProvider string

const (
	AuthenticationProviderGoogle   AuthenticationProvider = "google"
	AuthenticationProviderFacebook AuthenticationProvider = "facebook"
)

var AllAuthenticationProvider = []AuthenticationProvider{
	AuthenticationProviderGoogle,
	AuthenticationProviderFacebook,
}

func (e AuthenticationProvider) IsValid() bool {
	switch e {
	case AuthenticationProviderGoogle, AuthenticationProviderFacebook:
		return true
	}
	return false
}

func (e AuthenticationProvider) String() string {
	return string(e)
}

func (e *AuthenticationProvider) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AuthenticationProvider(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AuthenticationProvider", str)
	}
	return nil
}

func (e AuthenticationProvider) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
