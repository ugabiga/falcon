// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"fmt"
	"io"
	"strconv"
	"time"

	"github.com/ugabiga/falcon/internal/graph/model"
)

type Authentication struct {
	ID         string                 `json:"id"`
	UserID     string                 `json:"userID"`
	Provider   AuthenticationProvider `json:"provider"`
	Identifier string                 `json:"identifier"`
	UpdatedAt  time.Time              `json:"updatedAt"`
	CreatedAt  time.Time              `json:"createdAt"`
	User       *User                  `json:"user"`
}

type CreateTaskInput struct {
	TradingAccountID string     `json:"tradingAccountID"`
	Currency         string     `json:"currency"`
	Amount           float64    `json:"amount"`
	CryptoCurrency   string     `json:"cryptoCurrency"`
	Days             string     `json:"days"`
	Hours            string     `json:"hours"`
	Type             string     `json:"type"`
	Params           model.JSON `json:"params"`
}

type Task struct {
	ID                string          `json:"id"`
	TradingAccountID  string          `json:"tradingAccountID"`
	Currency          string          `json:"currency"`
	Amount            float64         `json:"amount"`
	CryptoCurrency    string          `json:"cryptoCurrency"`
	Cron              string          `json:"cron"`
	NextExecutionTime *time.Time      `json:"nextExecutionTime"`
	IsActive          bool            `json:"isActive"`
	Type              string          `json:"type"`
	Params            model.JSON      `json:"params"`
	UpdatedAt         time.Time       `json:"updatedAt"`
	CreatedAt         time.Time       `json:"createdAt"`
	TradingAccount    *TradingAccount `json:"tradingAccount"`
	TaskHistories     []*TaskHistory  `json:"taskHistories"`
}

type TaskHistory struct {
	ID        string    `json:"id"`
	TaskID    string    `json:"taskID"`
	IsSuccess bool      `json:"isSuccess"`
	UpdatedAt time.Time `json:"updatedAt"`
	CreatedAt time.Time `json:"createdAt"`
	Task      *Task     `json:"task"`
}

type TaskHistoryIndex struct {
	Task          *Task          `json:"task"`
	TaskHistories []*TaskHistory `json:"taskHistories"`
}

type TaskIndex struct {
	SelectedTradingAccount *TradingAccount   `json:"selectedTradingAccount"`
	TradingAccounts        []*TradingAccount `json:"tradingAccounts"`
}

type TradingAccount struct {
	ID         string    `json:"id"`
	UserID     string    `json:"userID"`
	Name       string    `json:"name"`
	Exchange   string    `json:"exchange"`
	IP         string    `json:"ip"`
	Identifier string    `json:"identifier"`
	UpdatedAt  time.Time `json:"updatedAt"`
	CreatedAt  time.Time `json:"createdAt"`
	User       *User     `json:"user"`
	Tasks      []*Task   `json:"tasks"`
}

type TradingAccountIndex struct {
	TradingAccounts []*TradingAccount `json:"tradingAccounts"`
}

type UpdateTaskInput struct {
	Currency       string     `json:"currency"`
	Amount         float64    `json:"amount"`
	CryptoCurrency string     `json:"cryptoCurrency"`
	Days           string     `json:"days"`
	Hours          string     `json:"hours"`
	Type           string     `json:"type"`
	IsActive       bool       `json:"isActive"`
	Params         model.JSON `json:"params"`
}

type UpdateUserInput struct {
	Name     string `json:"name"`
	Timezone string `json:"timezone"`
}

type User struct {
	ID              string            `json:"id"`
	Name            string            `json:"name"`
	Timezone        string            `json:"timezone"`
	UpdatedAt       time.Time         `json:"updatedAt"`
	CreatedAt       time.Time         `json:"createdAt"`
	Authentications []*Authentication `json:"authentications"`
	TradingAccounts []*TradingAccount `json:"tradingAccounts"`
}

type UserIndex struct {
	User *User `json:"user"`
}

// UserWhereInput is used for filtering User objects.
// Input was generated by ent.
type UserWhereInput struct {
	Not *UserWhereInput   `json:"not"`
	And []*UserWhereInput `json:"and"`
	Or  []*UserWhereInput `json:"or"`
	// id field predicates
	ID      *string  `json:"id"`
	IDNeq   *string  `json:"idNEQ"`
	IDIn    []string `json:"idIn"`
	IDNotIn []string `json:"idNotIn"`
	IDGt    *string  `json:"idGT"`
	IDGte   *string  `json:"idGTE"`
	IDLt    *string  `json:"idLT"`
	IDLte   *string  `json:"idLTE"`
	// name field predicates
	Name             *string  `json:"name"`
	NameNeq          *string  `json:"nameNEQ"`
	NameIn           []string `json:"nameIn"`
	NameNotIn        []string `json:"nameNotIn"`
	NameGt           *string  `json:"nameGT"`
	NameGte          *string  `json:"nameGTE"`
	NameLt           *string  `json:"nameLT"`
	NameLte          *string  `json:"nameLTE"`
	NameContains     *string  `json:"nameContains"`
	NameHasPrefix    *string  `json:"nameHasPrefix"`
	NameHasSuffix    *string  `json:"nameHasSuffix"`
	NameIsNil        *bool    `json:"nameIsNil"`
	NameNotNil       *bool    `json:"nameNotNil"`
	NameEqualFold    *string  `json:"nameEqualFold"`
	NameContainsFold *string  `json:"nameContainsFold"`
	// timezone field predicates
	Timezone             *string  `json:"timezone"`
	TimezoneNeq          *string  `json:"timezoneNEQ"`
	TimezoneIn           []string `json:"timezoneIn"`
	TimezoneNotIn        []string `json:"timezoneNotIn"`
	TimezoneGt           *string  `json:"timezoneGT"`
	TimezoneGte          *string  `json:"timezoneGTE"`
	TimezoneLt           *string  `json:"timezoneLT"`
	TimezoneLte          *string  `json:"timezoneLTE"`
	TimezoneContains     *string  `json:"timezoneContains"`
	TimezoneHasPrefix    *string  `json:"timezoneHasPrefix"`
	TimezoneHasSuffix    *string  `json:"timezoneHasSuffix"`
	TimezoneIsNil        *bool    `json:"timezoneIsNil"`
	TimezoneNotNil       *bool    `json:"timezoneNotNil"`
	TimezoneEqualFold    *string  `json:"timezoneEqualFold"`
	TimezoneContainsFold *string  `json:"timezoneContainsFold"`
	// updated_at field predicates
	UpdatedAt      *time.Time   `json:"updatedAt"`
	UpdatedAtNeq   *time.Time   `json:"updatedAtNEQ"`
	UpdatedAtIn    []*time.Time `json:"updatedAtIn"`
	UpdatedAtNotIn []*time.Time `json:"updatedAtNotIn"`
	UpdatedAtGt    *time.Time   `json:"updatedAtGT"`
	UpdatedAtGte   *time.Time   `json:"updatedAtGTE"`
	UpdatedAtLt    *time.Time   `json:"updatedAtLT"`
	UpdatedAtLte   *time.Time   `json:"updatedAtLTE"`
	// created_at field predicates
	CreatedAt      *time.Time   `json:"createdAt"`
	CreatedAtNeq   *time.Time   `json:"createdAtNEQ"`
	CreatedAtIn    []*time.Time `json:"createdAtIn"`
	CreatedAtNotIn []*time.Time `json:"createdAtNotIn"`
	CreatedAtGt    *time.Time   `json:"createdAtGT"`
	CreatedAtGte   *time.Time   `json:"createdAtGTE"`
	CreatedAtLt    *time.Time   `json:"createdAtLT"`
	CreatedAtLte   *time.Time   `json:"createdAtLTE"`
	// authentications edge predicates
	HasAuthentications *bool `json:"hasAuthentications"`
	// trading_accounts edge predicates
	HasTradingAccounts *bool `json:"hasTradingAccounts"`
}

type UserWithOptions struct {
	WithTradingAccounts bool `json:"withTradingAccounts"`
	WithAuthentications bool `json:"withAuthentications"`
}

type AuthenticationProvider string

const (
	AuthenticationProviderGoogle   AuthenticationProvider = "google"
	AuthenticationProviderFacebook AuthenticationProvider = "facebook"
)

var AllAuthenticationProvider = []AuthenticationProvider{
	AuthenticationProviderGoogle,
	AuthenticationProviderFacebook,
}

func (e AuthenticationProvider) IsValid() bool {
	switch e {
	case AuthenticationProviderGoogle, AuthenticationProviderFacebook:
		return true
	}
	return false
}

func (e AuthenticationProvider) String() string {
	return string(e)
}

func (e *AuthenticationProvider) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AuthenticationProvider(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AuthenticationProvider", str)
	}
	return nil
}

func (e AuthenticationProvider) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
