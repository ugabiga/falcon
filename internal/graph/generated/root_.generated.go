// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	Authentication struct {
		CreatedAt  func(childComplexity int) int
		ID         func(childComplexity int) int
		Identifier func(childComplexity int) int
		Provider   func(childComplexity int) int
		UpdatedAt  func(childComplexity int) int
		User       func(childComplexity int) int
		UserID     func(childComplexity int) int
	}

	Mutation struct {
		UpdateUser func(childComplexity int, input UpdateUserInput) int
	}

	Query struct {
		User  func(childComplexity int) int
		Users func(childComplexity int, where UserWhereInput) int
	}

	Task struct {
		CreatedAt         func(childComplexity int) int
		Cron              func(childComplexity int) int
		ID                func(childComplexity int) int
		IsActive          func(childComplexity int) int
		NextExecutionTime func(childComplexity int) int
		TaskHistories     func(childComplexity int) int
		TradingAccount    func(childComplexity int) int
		TradingAccountID  func(childComplexity int) int
		Type              func(childComplexity int) int
		UpdatedAt         func(childComplexity int) int
	}

	TaskHistory struct {
		CreatedAt func(childComplexity int) int
		ID        func(childComplexity int) int
		IsSuccess func(childComplexity int) int
		Task      func(childComplexity int) int
		TaskID    func(childComplexity int) int
		UpdatedAt func(childComplexity int) int
	}

	TradingAccount struct {
		CreatedAt  func(childComplexity int) int
		Currency   func(childComplexity int) int
		Exchange   func(childComplexity int) int
		ID         func(childComplexity int) int
		IP         func(childComplexity int) int
		Identifier func(childComplexity int) int
		Tasks      func(childComplexity int) int
		UpdatedAt  func(childComplexity int) int
		User       func(childComplexity int) int
		UserID     func(childComplexity int) int
	}

	User struct {
		Authentications func(childComplexity int) int
		CreatedAt       func(childComplexity int) int
		ID              func(childComplexity int) int
		Name            func(childComplexity int) int
		Timezone        func(childComplexity int) int
		TradingAccounts func(childComplexity int) int
		UpdatedAt       func(childComplexity int) int
	}
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "Authentication.createdAt":
		if e.complexity.Authentication.CreatedAt == nil {
			break
		}

		return e.complexity.Authentication.CreatedAt(childComplexity), true

	case "Authentication.id":
		if e.complexity.Authentication.ID == nil {
			break
		}

		return e.complexity.Authentication.ID(childComplexity), true

	case "Authentication.identifier":
		if e.complexity.Authentication.Identifier == nil {
			break
		}

		return e.complexity.Authentication.Identifier(childComplexity), true

	case "Authentication.provider":
		if e.complexity.Authentication.Provider == nil {
			break
		}

		return e.complexity.Authentication.Provider(childComplexity), true

	case "Authentication.updatedAt":
		if e.complexity.Authentication.UpdatedAt == nil {
			break
		}

		return e.complexity.Authentication.UpdatedAt(childComplexity), true

	case "Authentication.user":
		if e.complexity.Authentication.User == nil {
			break
		}

		return e.complexity.Authentication.User(childComplexity), true

	case "Authentication.userID":
		if e.complexity.Authentication.UserID == nil {
			break
		}

		return e.complexity.Authentication.UserID(childComplexity), true

	case "Mutation.updateUser":
		if e.complexity.Mutation.UpdateUser == nil {
			break
		}

		args, err := ec.field_Mutation_updateUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateUser(childComplexity, args["input"].(UpdateUserInput)), true

	case "Query.user":
		if e.complexity.Query.User == nil {
			break
		}

		return e.complexity.Query.User(childComplexity), true

	case "Query.users":
		if e.complexity.Query.Users == nil {
			break
		}

		args, err := ec.field_Query_users_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Users(childComplexity, args["where"].(UserWhereInput)), true

	case "Task.createdAt":
		if e.complexity.Task.CreatedAt == nil {
			break
		}

		return e.complexity.Task.CreatedAt(childComplexity), true

	case "Task.cron":
		if e.complexity.Task.Cron == nil {
			break
		}

		return e.complexity.Task.Cron(childComplexity), true

	case "Task.id":
		if e.complexity.Task.ID == nil {
			break
		}

		return e.complexity.Task.ID(childComplexity), true

	case "Task.isActive":
		if e.complexity.Task.IsActive == nil {
			break
		}

		return e.complexity.Task.IsActive(childComplexity), true

	case "Task.nextExecutionTime":
		if e.complexity.Task.NextExecutionTime == nil {
			break
		}

		return e.complexity.Task.NextExecutionTime(childComplexity), true

	case "Task.taskHistories":
		if e.complexity.Task.TaskHistories == nil {
			break
		}

		return e.complexity.Task.TaskHistories(childComplexity), true

	case "Task.tradingAccount":
		if e.complexity.Task.TradingAccount == nil {
			break
		}

		return e.complexity.Task.TradingAccount(childComplexity), true

	case "Task.tradingAccountID":
		if e.complexity.Task.TradingAccountID == nil {
			break
		}

		return e.complexity.Task.TradingAccountID(childComplexity), true

	case "Task.type":
		if e.complexity.Task.Type == nil {
			break
		}

		return e.complexity.Task.Type(childComplexity), true

	case "Task.updatedAt":
		if e.complexity.Task.UpdatedAt == nil {
			break
		}

		return e.complexity.Task.UpdatedAt(childComplexity), true

	case "TaskHistory.createdAt":
		if e.complexity.TaskHistory.CreatedAt == nil {
			break
		}

		return e.complexity.TaskHistory.CreatedAt(childComplexity), true

	case "TaskHistory.id":
		if e.complexity.TaskHistory.ID == nil {
			break
		}

		return e.complexity.TaskHistory.ID(childComplexity), true

	case "TaskHistory.isSuccess":
		if e.complexity.TaskHistory.IsSuccess == nil {
			break
		}

		return e.complexity.TaskHistory.IsSuccess(childComplexity), true

	case "TaskHistory.task":
		if e.complexity.TaskHistory.Task == nil {
			break
		}

		return e.complexity.TaskHistory.Task(childComplexity), true

	case "TaskHistory.taskID":
		if e.complexity.TaskHistory.TaskID == nil {
			break
		}

		return e.complexity.TaskHistory.TaskID(childComplexity), true

	case "TaskHistory.updatedAt":
		if e.complexity.TaskHistory.UpdatedAt == nil {
			break
		}

		return e.complexity.TaskHistory.UpdatedAt(childComplexity), true

	case "TradingAccount.createdAt":
		if e.complexity.TradingAccount.CreatedAt == nil {
			break
		}

		return e.complexity.TradingAccount.CreatedAt(childComplexity), true

	case "TradingAccount.currency":
		if e.complexity.TradingAccount.Currency == nil {
			break
		}

		return e.complexity.TradingAccount.Currency(childComplexity), true

	case "TradingAccount.exchange":
		if e.complexity.TradingAccount.Exchange == nil {
			break
		}

		return e.complexity.TradingAccount.Exchange(childComplexity), true

	case "TradingAccount.id":
		if e.complexity.TradingAccount.ID == nil {
			break
		}

		return e.complexity.TradingAccount.ID(childComplexity), true

	case "TradingAccount.ip":
		if e.complexity.TradingAccount.IP == nil {
			break
		}

		return e.complexity.TradingAccount.IP(childComplexity), true

	case "TradingAccount.identifier":
		if e.complexity.TradingAccount.Identifier == nil {
			break
		}

		return e.complexity.TradingAccount.Identifier(childComplexity), true

	case "TradingAccount.tasks":
		if e.complexity.TradingAccount.Tasks == nil {
			break
		}

		return e.complexity.TradingAccount.Tasks(childComplexity), true

	case "TradingAccount.updatedAt":
		if e.complexity.TradingAccount.UpdatedAt == nil {
			break
		}

		return e.complexity.TradingAccount.UpdatedAt(childComplexity), true

	case "TradingAccount.user":
		if e.complexity.TradingAccount.User == nil {
			break
		}

		return e.complexity.TradingAccount.User(childComplexity), true

	case "TradingAccount.userID":
		if e.complexity.TradingAccount.UserID == nil {
			break
		}

		return e.complexity.TradingAccount.UserID(childComplexity), true

	case "User.authentications":
		if e.complexity.User.Authentications == nil {
			break
		}

		return e.complexity.User.Authentications(childComplexity), true

	case "User.createdAt":
		if e.complexity.User.CreatedAt == nil {
			break
		}

		return e.complexity.User.CreatedAt(childComplexity), true

	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.name":
		if e.complexity.User.Name == nil {
			break
		}

		return e.complexity.User.Name(childComplexity), true

	case "User.timezone":
		if e.complexity.User.Timezone == nil {
			break
		}

		return e.complexity.User.Timezone(childComplexity), true

	case "User.tradingAccounts":
		if e.complexity.User.TradingAccounts == nil {
			break
		}

		return e.complexity.User.TradingAccounts(childComplexity), true

	case "User.updatedAt":
		if e.complexity.User.UpdatedAt == nil {
			break
		}

		return e.complexity.User.UpdatedAt(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputUpdateUserInput,
		ec.unmarshalInputUserWhereInput,
		ec.unmarshalInputUserWithOptions,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Query(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "api/graph/authentication.graphql", Input: `type Authentication {
    id: ID!
    userID: ID!
    provider: AuthenticationProvider!
    identifier: String!
    updatedAt: Time!
    createdAt: Time!
    user: User!
}

enum AuthenticationProvider {
    google
    facebook
}
`, BuiltIn: false},
	{Name: "api/graph/task.graphql", Input: `type Task {
    id: ID!
    tradingAccountID: ID!
    cron: String!
    nextExecutionTime: Time!
    isActive: Boolean!
    type: String!
    updatedAt: Time!
    createdAt: Time!
    tradingAccount: TradingAccount!
    taskHistories: [TaskHistory!]
}

`, BuiltIn: false},
	{Name: "api/graph/taskhistory.graphql", Input: `type TaskHistory {
    id: ID!
    taskID: ID!
    isSuccess: Boolean!
    updatedAt: Time!
    createdAt: Time!
    task: Task!
}
`, BuiltIn: false},
	{Name: "api/graph/tradingaccount.graphql", Input: `type TradingAccount {
    id: ID!
    userID: ID!
    exchange: String!
    currency: String!
    ip: String!
    identifier: String!
    updatedAt: Time!
    createdAt: Time!
    user: User!
    tasks: [Task!]
}
`, BuiltIn: false},
	{Name: "api/graph/user.graphql", Input: `scalar Time
directive @goField(forceResolver: Boolean, name: String) on FIELD_DEFINITION | INPUT_FIELD_DEFINITION
directive @goModel(model: String, models: [String!]) on OBJECT | INPUT_OBJECT | SCALAR | ENUM | INTERFACE | UNION

type Query {
    user: User!
    users(where: UserWhereInput!): [User!]!
}

type Mutation {
    updateUser(input: UpdateUserInput!): User!

}

type User {
    id: ID!
    name: String!
    timezone: String!
    updatedAt: Time!
    createdAt: Time!
    authentications: [Authentication!]
    tradingAccounts: [TradingAccount!]
}

input UserWithOptions {
    withTradingAccounts: Boolean!
    withAuthentications: Boolean!
}

input UpdateUserInput {
    name: String!
    timezone: String!
}

"""
UserWhereInput is used for filtering User objects.
Input was generated by ent.
"""
input UserWhereInput {
    not: UserWhereInput
    and: [UserWhereInput!]
    or: [UserWhereInput!]
    """id field predicates"""
    id: ID
    idNEQ: ID
    idIn: [ID!]
    idNotIn: [ID!]
    idGT: ID
    idGTE: ID
    idLT: ID
    idLTE: ID
    """name field predicates"""
    name: String
    nameNEQ: String
    nameIn: [String!]
    nameNotIn: [String!]
    nameGT: String
    nameGTE: String
    nameLT: String
    nameLTE: String
    nameContains: String
    nameHasPrefix: String
    nameHasSuffix: String
    nameIsNil: Boolean
    nameNotNil: Boolean
    nameEqualFold: String
    nameContainsFold: String
    """timezone field predicates"""
    timezone: String
    timezoneNEQ: String
    timezoneIn: [String!]
    timezoneNotIn: [String!]
    timezoneGT: String
    timezoneGTE: String
    timezoneLT: String
    timezoneLTE: String
    timezoneContains: String
    timezoneHasPrefix: String
    timezoneHasSuffix: String
    timezoneIsNil: Boolean
    timezoneNotNil: Boolean
    timezoneEqualFold: String
    timezoneContainsFold: String
    """updated_at field predicates"""
    updatedAt: Time
    updatedAtNEQ: Time
    updatedAtIn: [Time!]
    updatedAtNotIn: [Time!]
    updatedAtGT: Time
    updatedAtGTE: Time
    updatedAtLT: Time
    updatedAtLTE: Time
    """created_at field predicates"""
    createdAt: Time
    createdAtNEQ: Time
    createdAtIn: [Time!]
    createdAtNotIn: [Time!]
    createdAtGT: Time
    createdAtGTE: Time
    createdAtLT: Time
    createdAtLTE: Time
    """authentications edge predicates"""
    hasAuthentications: Boolean
    #    hasAuthenticationsWith: [AuthenticationWhereInput!]
    """trading_accounts edge predicates"""
    hasTradingAccounts: Boolean
    #    hasTradingAccountsWith: [TradingAccountWhereInput!]
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
