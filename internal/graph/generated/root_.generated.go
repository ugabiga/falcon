// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	Authentication struct {
		CreatedAt  func(childComplexity int) int
		ID         func(childComplexity int) int
		Identifier func(childComplexity int) int
		Provider   func(childComplexity int) int
		UpdatedAt  func(childComplexity int) int
		User       func(childComplexity int) int
		UserID     func(childComplexity int) int
	}

	Mutation struct {
		CreateTask           func(childComplexity int, input CreateTaskInput) int
		CreateTradingAccount func(childComplexity int, name string, exchange string, identifier string, credential string) int
		UpdateTask           func(childComplexity int, id int, input UpdateTaskInput) int
		UpdateTradingAccount func(childComplexity int, id int, name *string, exchange *string, identifier *string, credential *string) int
		UpdateUser           func(childComplexity int, input UpdateUserInput) int
	}

	Query struct {
		TaskHistoryIndex    func(childComplexity int, taskID int) int
		TaskIndex           func(childComplexity int, tradingAccountID *int) int
		TradingAccountIndex func(childComplexity int) int
		UserIndex           func(childComplexity int) int
	}

	Task struct {
		Amount            func(childComplexity int) int
		CreatedAt         func(childComplexity int) int
		Cron              func(childComplexity int) int
		CryptoCurrency    func(childComplexity int) int
		Currency          func(childComplexity int) int
		ID                func(childComplexity int) int
		IsActive          func(childComplexity int) int
		NextExecutionTime func(childComplexity int) int
		Params            func(childComplexity int) int
		TaskHistories     func(childComplexity int) int
		TradingAccount    func(childComplexity int) int
		TradingAccountID  func(childComplexity int) int
		Type              func(childComplexity int) int
		UpdatedAt         func(childComplexity int) int
	}

	TaskHistory struct {
		CreatedAt func(childComplexity int) int
		ID        func(childComplexity int) int
		IsSuccess func(childComplexity int) int
		Task      func(childComplexity int) int
		TaskID    func(childComplexity int) int
		UpdatedAt func(childComplexity int) int
	}

	TaskHistoryIndex struct {
		Task          func(childComplexity int) int
		TaskHistories func(childComplexity int) int
	}

	TaskIndex struct {
		SelectedTradingAccount func(childComplexity int) int
		TradingAccounts        func(childComplexity int) int
	}

	TradingAccount struct {
		CreatedAt  func(childComplexity int) int
		Exchange   func(childComplexity int) int
		ID         func(childComplexity int) int
		IP         func(childComplexity int) int
		Identifier func(childComplexity int) int
		Name       func(childComplexity int) int
		Tasks      func(childComplexity int) int
		UpdatedAt  func(childComplexity int) int
		User       func(childComplexity int) int
		UserID     func(childComplexity int) int
	}

	TradingAccountIndex struct {
		TradingAccounts func(childComplexity int) int
	}

	User struct {
		Authentications func(childComplexity int) int
		CreatedAt       func(childComplexity int) int
		ID              func(childComplexity int) int
		Name            func(childComplexity int) int
		Timezone        func(childComplexity int) int
		TradingAccounts func(childComplexity int) int
		UpdatedAt       func(childComplexity int) int
	}

	UserIndex struct {
		User func(childComplexity int) int
	}
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "Authentication.createdAt":
		if e.complexity.Authentication.CreatedAt == nil {
			break
		}

		return e.complexity.Authentication.CreatedAt(childComplexity), true

	case "Authentication.id":
		if e.complexity.Authentication.ID == nil {
			break
		}

		return e.complexity.Authentication.ID(childComplexity), true

	case "Authentication.identifier":
		if e.complexity.Authentication.Identifier == nil {
			break
		}

		return e.complexity.Authentication.Identifier(childComplexity), true

	case "Authentication.provider":
		if e.complexity.Authentication.Provider == nil {
			break
		}

		return e.complexity.Authentication.Provider(childComplexity), true

	case "Authentication.updatedAt":
		if e.complexity.Authentication.UpdatedAt == nil {
			break
		}

		return e.complexity.Authentication.UpdatedAt(childComplexity), true

	case "Authentication.user":
		if e.complexity.Authentication.User == nil {
			break
		}

		return e.complexity.Authentication.User(childComplexity), true

	case "Authentication.userID":
		if e.complexity.Authentication.UserID == nil {
			break
		}

		return e.complexity.Authentication.UserID(childComplexity), true

	case "Mutation.createTask":
		if e.complexity.Mutation.CreateTask == nil {
			break
		}

		args, err := ec.field_Mutation_createTask_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateTask(childComplexity, args["input"].(CreateTaskInput)), true

	case "Mutation.createTradingAccount":
		if e.complexity.Mutation.CreateTradingAccount == nil {
			break
		}

		args, err := ec.field_Mutation_createTradingAccount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateTradingAccount(childComplexity, args["name"].(string), args["exchange"].(string), args["identifier"].(string), args["credential"].(string)), true

	case "Mutation.updateTask":
		if e.complexity.Mutation.UpdateTask == nil {
			break
		}

		args, err := ec.field_Mutation_updateTask_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateTask(childComplexity, args["id"].(int), args["input"].(UpdateTaskInput)), true

	case "Mutation.updateTradingAccount":
		if e.complexity.Mutation.UpdateTradingAccount == nil {
			break
		}

		args, err := ec.field_Mutation_updateTradingAccount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateTradingAccount(childComplexity, args["id"].(int), args["name"].(*string), args["exchange"].(*string), args["identifier"].(*string), args["credential"].(*string)), true

	case "Mutation.updateUser":
		if e.complexity.Mutation.UpdateUser == nil {
			break
		}

		args, err := ec.field_Mutation_updateUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateUser(childComplexity, args["input"].(UpdateUserInput)), true

	case "Query.taskHistoryIndex":
		if e.complexity.Query.TaskHistoryIndex == nil {
			break
		}

		args, err := ec.field_Query_taskHistoryIndex_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.TaskHistoryIndex(childComplexity, args["taskID"].(int)), true

	case "Query.taskIndex":
		if e.complexity.Query.TaskIndex == nil {
			break
		}

		args, err := ec.field_Query_taskIndex_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.TaskIndex(childComplexity, args["tradingAccountID"].(*int)), true

	case "Query.tradingAccountIndex":
		if e.complexity.Query.TradingAccountIndex == nil {
			break
		}

		return e.complexity.Query.TradingAccountIndex(childComplexity), true

	case "Query.userIndex":
		if e.complexity.Query.UserIndex == nil {
			break
		}

		return e.complexity.Query.UserIndex(childComplexity), true

	case "Task.amount":
		if e.complexity.Task.Amount == nil {
			break
		}

		return e.complexity.Task.Amount(childComplexity), true

	case "Task.createdAt":
		if e.complexity.Task.CreatedAt == nil {
			break
		}

		return e.complexity.Task.CreatedAt(childComplexity), true

	case "Task.cron":
		if e.complexity.Task.Cron == nil {
			break
		}

		return e.complexity.Task.Cron(childComplexity), true

	case "Task.cryptoCurrency":
		if e.complexity.Task.CryptoCurrency == nil {
			break
		}

		return e.complexity.Task.CryptoCurrency(childComplexity), true

	case "Task.currency":
		if e.complexity.Task.Currency == nil {
			break
		}

		return e.complexity.Task.Currency(childComplexity), true

	case "Task.id":
		if e.complexity.Task.ID == nil {
			break
		}

		return e.complexity.Task.ID(childComplexity), true

	case "Task.isActive":
		if e.complexity.Task.IsActive == nil {
			break
		}

		return e.complexity.Task.IsActive(childComplexity), true

	case "Task.nextExecutionTime":
		if e.complexity.Task.NextExecutionTime == nil {
			break
		}

		return e.complexity.Task.NextExecutionTime(childComplexity), true

	case "Task.params":
		if e.complexity.Task.Params == nil {
			break
		}

		return e.complexity.Task.Params(childComplexity), true

	case "Task.taskHistories":
		if e.complexity.Task.TaskHistories == nil {
			break
		}

		return e.complexity.Task.TaskHistories(childComplexity), true

	case "Task.tradingAccount":
		if e.complexity.Task.TradingAccount == nil {
			break
		}

		return e.complexity.Task.TradingAccount(childComplexity), true

	case "Task.tradingAccountID":
		if e.complexity.Task.TradingAccountID == nil {
			break
		}

		return e.complexity.Task.TradingAccountID(childComplexity), true

	case "Task.type":
		if e.complexity.Task.Type == nil {
			break
		}

		return e.complexity.Task.Type(childComplexity), true

	case "Task.updatedAt":
		if e.complexity.Task.UpdatedAt == nil {
			break
		}

		return e.complexity.Task.UpdatedAt(childComplexity), true

	case "TaskHistory.createdAt":
		if e.complexity.TaskHistory.CreatedAt == nil {
			break
		}

		return e.complexity.TaskHistory.CreatedAt(childComplexity), true

	case "TaskHistory.id":
		if e.complexity.TaskHistory.ID == nil {
			break
		}

		return e.complexity.TaskHistory.ID(childComplexity), true

	case "TaskHistory.isSuccess":
		if e.complexity.TaskHistory.IsSuccess == nil {
			break
		}

		return e.complexity.TaskHistory.IsSuccess(childComplexity), true

	case "TaskHistory.task":
		if e.complexity.TaskHistory.Task == nil {
			break
		}

		return e.complexity.TaskHistory.Task(childComplexity), true

	case "TaskHistory.taskID":
		if e.complexity.TaskHistory.TaskID == nil {
			break
		}

		return e.complexity.TaskHistory.TaskID(childComplexity), true

	case "TaskHistory.updatedAt":
		if e.complexity.TaskHistory.UpdatedAt == nil {
			break
		}

		return e.complexity.TaskHistory.UpdatedAt(childComplexity), true

	case "TaskHistoryIndex.task":
		if e.complexity.TaskHistoryIndex.Task == nil {
			break
		}

		return e.complexity.TaskHistoryIndex.Task(childComplexity), true

	case "TaskHistoryIndex.taskHistories":
		if e.complexity.TaskHistoryIndex.TaskHistories == nil {
			break
		}

		return e.complexity.TaskHistoryIndex.TaskHistories(childComplexity), true

	case "TaskIndex.selectedTradingAccount":
		if e.complexity.TaskIndex.SelectedTradingAccount == nil {
			break
		}

		return e.complexity.TaskIndex.SelectedTradingAccount(childComplexity), true

	case "TaskIndex.tradingAccounts":
		if e.complexity.TaskIndex.TradingAccounts == nil {
			break
		}

		return e.complexity.TaskIndex.TradingAccounts(childComplexity), true

	case "TradingAccount.createdAt":
		if e.complexity.TradingAccount.CreatedAt == nil {
			break
		}

		return e.complexity.TradingAccount.CreatedAt(childComplexity), true

	case "TradingAccount.exchange":
		if e.complexity.TradingAccount.Exchange == nil {
			break
		}

		return e.complexity.TradingAccount.Exchange(childComplexity), true

	case "TradingAccount.id":
		if e.complexity.TradingAccount.ID == nil {
			break
		}

		return e.complexity.TradingAccount.ID(childComplexity), true

	case "TradingAccount.ip":
		if e.complexity.TradingAccount.IP == nil {
			break
		}

		return e.complexity.TradingAccount.IP(childComplexity), true

	case "TradingAccount.identifier":
		if e.complexity.TradingAccount.Identifier == nil {
			break
		}

		return e.complexity.TradingAccount.Identifier(childComplexity), true

	case "TradingAccount.name":
		if e.complexity.TradingAccount.Name == nil {
			break
		}

		return e.complexity.TradingAccount.Name(childComplexity), true

	case "TradingAccount.tasks":
		if e.complexity.TradingAccount.Tasks == nil {
			break
		}

		return e.complexity.TradingAccount.Tasks(childComplexity), true

	case "TradingAccount.updatedAt":
		if e.complexity.TradingAccount.UpdatedAt == nil {
			break
		}

		return e.complexity.TradingAccount.UpdatedAt(childComplexity), true

	case "TradingAccount.user":
		if e.complexity.TradingAccount.User == nil {
			break
		}

		return e.complexity.TradingAccount.User(childComplexity), true

	case "TradingAccount.userID":
		if e.complexity.TradingAccount.UserID == nil {
			break
		}

		return e.complexity.TradingAccount.UserID(childComplexity), true

	case "TradingAccountIndex.tradingAccounts":
		if e.complexity.TradingAccountIndex.TradingAccounts == nil {
			break
		}

		return e.complexity.TradingAccountIndex.TradingAccounts(childComplexity), true

	case "User.authentications":
		if e.complexity.User.Authentications == nil {
			break
		}

		return e.complexity.User.Authentications(childComplexity), true

	case "User.createdAt":
		if e.complexity.User.CreatedAt == nil {
			break
		}

		return e.complexity.User.CreatedAt(childComplexity), true

	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.name":
		if e.complexity.User.Name == nil {
			break
		}

		return e.complexity.User.Name(childComplexity), true

	case "User.timezone":
		if e.complexity.User.Timezone == nil {
			break
		}

		return e.complexity.User.Timezone(childComplexity), true

	case "User.tradingAccounts":
		if e.complexity.User.TradingAccounts == nil {
			break
		}

		return e.complexity.User.TradingAccounts(childComplexity), true

	case "User.updatedAt":
		if e.complexity.User.UpdatedAt == nil {
			break
		}

		return e.complexity.User.UpdatedAt(childComplexity), true

	case "UserIndex.user":
		if e.complexity.UserIndex.User == nil {
			break
		}

		return e.complexity.UserIndex.User(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputCreateTaskInput,
		ec.unmarshalInputUpdateTaskInput,
		ec.unmarshalInputUpdateUserInput,
		ec.unmarshalInputUserWhereInput,
		ec.unmarshalInputUserWithOptions,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Query(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "api/graph/authentication.graphql", Input: `type Authentication {
    id: ID!
    userID: ID!
    provider: AuthenticationProvider!
    identifier: String!
    updatedAt: Time!
    createdAt: Time!
    user: User!
}

enum AuthenticationProvider {
    google
    facebook
}
`, BuiltIn: false},
	{Name: "api/graph/task.graphql", Input: `extend type Query {
    taskIndex(tradingAccountID: ID): TaskIndex
}

extend type Mutation {
    createTask(input: CreateTaskInput!): Task!
    updateTask(id: ID!, input: UpdateTaskInput!): Task!
}

input CreateTaskInput {
    tradingAccountID: ID!
    currency: String!
    amount: Float!
    cryptoCurrency: String!
    days: String!
    hours: String!
    type: String!
    params: JSON
}

input UpdateTaskInput {
    currency: String!
    amount: Float!
    cryptoCurrency: String!
    days: String!
    hours: String!
    type: String!
    isActive: Boolean!
    params: JSON
}

type TaskIndex{
    selectedTradingAccount: TradingAccount
    tradingAccounts: [TradingAccount!]
}


type Task {
    id: ID!
    tradingAccountID: ID!
    currency: String!
    amount: Float!
    cryptoCurrency: String!
    cron: String!
    nextExecutionTime: Time
    isActive: Boolean!
    type: String!
    params: JSON
    updatedAt: Time!
    createdAt: Time!
    tradingAccount: TradingAccount!
    taskHistories: [TaskHistory!]
}

scalar JSON
`, BuiltIn: false},
	{Name: "api/graph/taskhistory.graphql", Input: `extend type Query {
    taskHistoryIndex(taskID: ID!): TaskHistoryIndex!
}

type TaskHistoryIndex{
    task: Task!
    taskHistories: [TaskHistory!]
}

type TaskHistory {
    id: ID!
    taskID: ID!
    isSuccess: Boolean!
    updatedAt: Time!
    createdAt: Time!
    task: Task!
}
`, BuiltIn: false},
	{Name: "api/graph/tradingaccount.graphql", Input: `extend type Query {
    tradingAccountIndex: TradingAccountIndex!
}

extend type Mutation {
    createTradingAccount(
        name: String!
        exchange: String!
        identifier: String!
        credential: String!
    ): TradingAccount!
    updateTradingAccount(
        id: ID!
        name: String
        exchange: String
        identifier: String
        credential: String
    ): Boolean!
}

type TradingAccountIndex {
    tradingAccounts: [TradingAccount!]
}

type TradingAccount {
    id: ID!
    userID: ID!
    name: String!
    exchange: String!
    ip: String!
    identifier: String!
    updatedAt: Time!
    createdAt: Time!
    user: User!
    tasks: [Task!]
}
`, BuiltIn: false},
	{Name: "api/graph/user.graphql", Input: `scalar Time
directive @goField(forceResolver: Boolean, name: String) on FIELD_DEFINITION | INPUT_FIELD_DEFINITION
directive @goModel(model: String, models: [String!]) on OBJECT | INPUT_OBJECT | SCALAR | ENUM | INTERFACE | UNION

type Query {
    userIndex: UserIndex!
}

type Mutation {
    updateUser(input: UpdateUserInput!): User!

}

type UserIndex {
    user: User!
}

type User {
    id: ID!
    name: String!
    timezone: String!
    updatedAt: Time!
    createdAt: Time!
    authentications: [Authentication!]
    tradingAccounts: [TradingAccount!]
}

input UserWithOptions {
    withTradingAccounts: Boolean!
    withAuthentications: Boolean!
}

input UpdateUserInput {
    name: String!
    timezone: String!
}

"""
UserWhereInput is used for filtering User objects.
Input was generated by ent.
"""
input UserWhereInput {
    not: UserWhereInput
    and: [UserWhereInput!]
    or: [UserWhereInput!]
    """id field predicates"""
    id: ID
    idNEQ: ID
    idIn: [ID!]
    idNotIn: [ID!]
    idGT: ID
    idGTE: ID
    idLT: ID
    idLTE: ID
    """name field predicates"""
    name: String
    nameNEQ: String
    nameIn: [String!]
    nameNotIn: [String!]
    nameGT: String
    nameGTE: String
    nameLT: String
    nameLTE: String
    nameContains: String
    nameHasPrefix: String
    nameHasSuffix: String
    nameIsNil: Boolean
    nameNotNil: Boolean
    nameEqualFold: String
    nameContainsFold: String
    """timezone field predicates"""
    timezone: String
    timezoneNEQ: String
    timezoneIn: [String!]
    timezoneNotIn: [String!]
    timezoneGT: String
    timezoneGTE: String
    timezoneLT: String
    timezoneLTE: String
    timezoneContains: String
    timezoneHasPrefix: String
    timezoneHasSuffix: String
    timezoneIsNil: Boolean
    timezoneNotNil: Boolean
    timezoneEqualFold: String
    timezoneContainsFold: String
    """updated_at field predicates"""
    updatedAt: Time
    updatedAtNEQ: Time
    updatedAtIn: [Time!]
    updatedAtNotIn: [Time!]
    updatedAtGT: Time
    updatedAtGTE: Time
    updatedAtLT: Time
    updatedAtLTE: Time
    """created_at field predicates"""
    createdAt: Time
    createdAtNEQ: Time
    createdAtIn: [Time!]
    createdAtNotIn: [Time!]
    createdAtGT: Time
    createdAtGTE: Time
    createdAtLT: Time
    createdAtLTE: Time
    """authentications edge predicates"""
    hasAuthentications: Boolean
    #    hasAuthenticationsWith: [AuthenticationWhereInput!]
    """trading_accounts edge predicates"""
    hasTradingAccounts: Boolean
    #    hasTradingAccountsWith: [TradingAccountWhereInput!]
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
